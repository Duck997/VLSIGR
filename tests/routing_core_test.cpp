#include <gtest/gtest.h>
#include <string>
#include <sstream>

#include "router/routing_core.hpp"
#include "router/ispd_data.hpp"

using namespace vlsigr;

TEST(RoutingCore, CompleteRoutingPipeline) {
    // Small ISPD-like input: 3x2 grid, 1 layer, 1 net with 2 pins.
    std::string input = R"(grid 3 2 1
vertical capacity 10
horizontal capacity 20
minimum width 1
minimum spacing 1
via spacing 1
0 0 10 10
num net 1
net0 0 2 1
0 0 1
20 10 1
0
)";
    std::istringstream iss(input);
    auto data = parse_ispd(iss);

    RoutingCore rc;
    
    // Use new interface: route() handles preroute + full pipeline
    try {
        rc.route(data, true);  // leave=true to stop after preroute
    } catch (...) {
        // Ignore exceptions for test
    }

    // Grid dimensions should be initialized
    EXPECT_EQ(rc.grid().width(), 3u);
    EXPECT_EQ(rc.grid().height(), 2u);
    
    // After preroute, nets should have twopins
    ASSERT_GE(data.nets.size(), 1u);
    const auto& net = data.nets[0];
    EXPECT_GE(net.twopin.size(), 1u);
    
    if (!net.twopin.empty()) {
        const auto& tp = net.twopin[0];
        // Path should be generated by Lshape in preroute
        EXPECT_GT(tp.path.size(), 0u);
    }
}

TEST(RoutingCore, FullRoutingConvergence) {
    // Test that routing can handle simple case without crash
    std::string input = R"(grid 5 5 2
vertical capacity 10 10
horizontal capacity 10 10
minimum width 1 1
minimum spacing 1 1
via spacing 1 1
0 0 10 10
num net 1
net0 0 2 1
0 0 1
40 40 1
0
)";
    std::istringstream iss(input);
    auto data = parse_ispd(iss);

    RoutingCore rc;
    
    // Should complete without crash
    EXPECT_NO_THROW({
        try {
            rc.route(data, false);
        } catch (bool done) {
            // Expected exception for early termination
        }
    });
}
